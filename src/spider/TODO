# -*- indented-text -*-

-----------------------------------------------------------------------

Build system TODO:

1. Make the Makefiles tidier.

[DONE] - always in $|(prefix)/etc/spider/spider.conf
2. Make the options based around autoconf.  In particular, make the
   conf file location easy to change.  Also, we can the put that into
   a Makefile.

[DONE]
3. Add install targets that get things right.  Use dependencies.  Use
   $(prefix) as well, so that we can install into random hierarchies.
   This is a good thing[tm].

[DONE]
4. Output a line every time we recurse into a subdirectory.

5. Put every module into it's own directory.  And make alex's modules
   fit into this standard.
[DONE]
6. Make VPATH work.

-----------------------------------------------------------------------

TODO:

7)  Write a few man pages.  And a module design guide?  And a protocol
    definition?

10) Add a command to change passwd, and make it update the passwd file
    on disk.  Maybe fork and exec an appropriate 'sed' command?  Or
    just do it inside (probably best to fork first).

17) WEIRD BUG: If input comes in too fast, then spider somehow
    performs an illegal seek on the user file descriptor (ESPIPE).
    Unfortunately, This is probably a problem with stdio.

19) Ensure that binary data is *disallowed*.  This would cause severe
    fuckups if it got sent through Spider; all assumptions are that we
    are dealing with a line of text, everywhere.

    NO!!! Don't do this.  When Spider has it's IO system rewritten, it
    will handle binary data, by treating it as arbitrarily long
    lines.  So long as the remainder of the protocol is followed (ie:
    1 line of command, and 1 trailing line of terminator), then the
    binary data will be left untouched.  We must use the mem*
    functions, rather than the str* functions, so as to allow NULLs in
    the data.

20) Rewrite *all* of spider to use low level i/o, instead of stdio.
    This is because stdio will blindly read in as many lines as is
    possible, meaning that if we have back2back messages, only the
    first will get processed, the next will be ignored.  I incorrectly
    assumed that select(2) would handle this.

24) Initial message should be in real Spider format for easier parsing
    by client software.

26) Mark commands on a module which has terminated as "unavailable",
    and try to resurrect the module later.  Return a "4x0" reply to
    the user instead.

28) Find a way of speeding up name lookups in the connection array.

30) Change Cmd to hold the fd of the module concerned, rather than the 
    address.  I musta been a bozo to thoughta that one!

31) Change the functions in init.c to use fgets, instead of our
    "proprietary" i/o routines.  Also, change them to use strtok for
    parsing.  That's ANSI, y'know.

32) Change everything to fully use the autoconf definitions, so as to
    provide maximum portability.  Also, work out how to get an RCS
    version string distributed everywhere.  And there *must* be an
    easier way of getting the CONFIG_FILE definition from config.h...

33) Write install targets for all the Makefiles.

FOR ALEX:

1) Login/logout announcements for the talker.

2) Ensure that email is only seeable/retrieveable by the command
    issueing user.

3) Stop {talkser,msg}mod from core dumping on EOF.

4) Ensure that {talker,msg}mod are case-indendent, everywhere...

5) Stop that pause!  At least for every reply.  It should only be
   between replies which are sent out at the same time. (ie:
   OK_UNSOLIC types).

DONE:

1) Finalize the details of the LOGIN command.

3) Do Spider/module error handling.  This will involve changing
   libmod.a in some unknown way.

4) Handle signals better.  In particular, we should be aware if any of
   our children die prematurely (SIGCHLD).

5) Write a proper main loop, which select(2)'s on a listening socket.
   Depends on the LOGIN command working correctly.  (fairly easy)

11) Once Spider has benn more or less finished, update libmod.a to use
    a couple of the newer functions, such as getline.

12) Make sure that you can only login just after a connection has been
    accepted.

13) Add a "host" field to the usr part of the conn structure.  And
    print it out in the WHO command.

14) Write a pager module.

15) Write a undo_cmds function, for when a module dies.

18) Print up a one-line header upon initial connection, so that Spider
    can be identified as such.

21) Rearrange main loop to be an event handler like this:

    while(1) {
        select(...);
        figure_out_event_type();
        switch(event_type) {
        case NEW_CONN:
            /* accept new conn, setup initial Conn, mark as need LOGIN */
        case CLIENT_DEATH:
            /* Tidyup, after client */
        case MODULE_DEATH:
            /* Tidyup, after module */
        case SERVER_DEATH:
            /* commit suicide */
        case UNKNOWN_SIGNAL:
            /* send an error to logger */
        case CLIENT_MSG:
            /* Read it in, parse & shove out to module */
        case MODULE_MSG:
            /* Read it in, find user & shove out */
        }
    }

    Really, should break all signal stuff into an extra file.  Then,
    have two functions for each signal: one as a sighandler to mark
    that it happened, and one to actually do the function.

22) Check in all the source files again, using $Header: /home/ncvs/src/spider/TODO,v 1.1 1999/03/11 15:39:48 dom Exp $ in place of 
    $Id: TODO,v 1.1 1999/03/11 15:39:48 dom Exp $.  That will make sorting out which files are which easier in
    post-compile debugging.

23) Check for options:

    1. Alternative configuration file.
    2. nofork mode.

25) Open PIDFILE exclusively, exit if it's already there, and the PID
    exists. 

27) Rewrite connect states: s_not, s_init, s_conn.

29) Make who only show people in the s_conn state.

34) Get Makefile working for DOC subdir.

DISTANT THOUGHTS FOR FUTURE VERSIONS:

1) Think about letting modules use other commands.  Tricky to get
   right.

2) Make Spider re-read config and re-init on a HUP signal.  Tricky to
   get semantics right.

3) Are the trees to slow?  Should they be replaced by hashes? (yes,
   yes, yes)

4) Find a reasonable way of implementing a timeout on user reads (not
   modules).

5) Maybe we should allow >1 simultaneous logon?

6) Prioritize messages?  ie: have talker output (say) secondary to new
   cmds from users?  This might be necessary if we suddenly have 25 users
   on the same talker channel, and all the output needs to go out at once.
   This will probably depend on profiling under high load.

7) Use shared memory to provide output in one process & input in another?
