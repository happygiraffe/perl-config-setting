.\" ############################################################
.\" 
.\" This is the final personal submission for the project. 
.\" 
.\" $Id: fir.me,v 1.1 1999/03/11 15:39:49 dom Exp $
.\" 
.\" $Log: fir.me,v $
.\" Revision 1.1  1999/03/11 15:39:49  dom
.\" Initial revision
.\"
.\" Revision 1.0  1996/05/14 17:23:04  dom
.\" Initial revision
.\"
.\"
.\" ############################################################
.\" 
.\" Here's a nice centered page number at the bottom:
.fo ''%''
.\" 
.(l C
.sz +8
Final Individual Report
by Dominic Mitchell
.sz -4
(\fCdom@myrddin.demon.co.uk\fP)
.sz -4
.)l 
.sp 1i
.\" 
.\" ############################################################
.\" 
.\" o Method of Approach
.\" o Problems encountered
.\" o lessons learned, personally
.\" o Outstanding tasks and future ideas
.\" 
.sh 1 "Introduction"
.lp
Firstly, a here is a brief summary of the overall aims of our project:
.pp
We created a multi-user client/server Bulletin Board System (BBS) for
our project.  The server is multi-threaded and runs under Unix.  The
clients connect to the server via TCP/IP.  We have created two clients
so far; one for MS Windows and one for X windows.
.pp
I took on several roles within the project.  Initially, with all the
other group members, a design was created for the basic BBS.  Then, I
proceeded to design, implement and document the main server (Spider).
Finally, I created the X Windows client for the Bulletin Board, along
with Matt Davidson.
.pp
In this report, I shall attempt to explain the methods that I used,
what problems I encountered and what experience I gained during the
development of the project.  I shall also detail several ideas which
have occurred to me during the course of the project.
.\" 
.\" ############################################################
.\" 
.sh 1 "Method of Approach"
.lp
The methods that I used for development varied between the different
phases of the project.  Overall, however, it must be noted that no
.i "formal"
design methods were used.  This was not a conscious decision, but it
was an inevitable one.  The main reason for this was simply that what
we were doing did not fit in easily with the methodologies that we had
been taught (eg: SSADM).  A secondary reason was the lack of detailed
specifications.  What specifications existed, where drafted on a rough
basis, such that we could write a program easily, rather than perform
a formal verification.
.pp
The initial design period was mainly catered for by listing ideas that
we wanted to do, presenting them to the group and discussing them.
After a reasonably short period, we had produced a fairly basic
design, which seemed workable.  At this point, tasks were allocated
and we set about designing our individual components.
.pp
As mentioned before, I was allocated the task of creating the main
portion of the server, "Spider".  The basic outline of the code had
already been thought of during the design phase.  It was particularly
easy to implement, because of a particular feature of Unix: the
\fCselect(2)\fP call.  This allows a program to wait for a file handle
to become ready for either reading or writing, with an optional
time-out.  Thus, I could use it to implement an event handler, for
incoming messages from both clients and modules.  It could also handle
new connections, as a new connection arriving at a listening socket
counts as a "read".
.pp
The outline of the code was very simple; There would be one function
to set up the various data structures and other initializations that
would be needed and the rest of the program would be a simple loop to
act appropriately on the type of event just received.  The
initialization function had several sub-functions, mainly to setup the
modules (& hence the protocol) and the list of users.  Also, it would
set up signal handlers for various events, turn the process into a
daemon and read in the configuration file.
.pp
It turned out that writing the initialization code was the harder part
of the two tasks that had to be done, and once taken care of, writing
the rest of the event handling code was relatively easy.  To start
with, I did not use any networking functions, and merely created a
single, already logged in user, on the console, who could enter
commands into the system.  This was fairly easy to do.  Then, I
studied the paper "An Introductory 4.4BSD IPC Tutorial" to see how the
networking code should be done.  After a brief while, I realized that
it was in fact very easy and added the code into Spider, where it
consisted of about 30 extra lines.
.pp
Since then, the basic code has remained almost the same.  I changed
several things to avoid crashing badly when a NULL pointer is seen,
but apart from that little else has changed.
.pp
The X Windows client was developed briefly, and in combination with
Matt Davidson.  We worked together, by actually sitting at the same
terminal to do the work, so that we could comment on one another's
code as it was being written, as well as debate ideas and suggest
designs. 
.pp
With the X Windows client, we felt that the main point was to first
get the interface together, as that would shape the rest of the
program.  This was quite quick, thanks to the language that we had
chosen (Tcl/Tk).  After this, a few utility functions, such as DoCmd
were coded, in order to make life easier for developing the rest of
the functionality.
.\" 
.\" ############################################################
.\" 
.sh 1 "Problems Encountered"
.lp
The main problem to begin with was simply a lack of definition.  The
main design which we had produced was far too open-ended to work with
properly, so we had to sit down and code a few test programs in order
to finalize the design.  This early prototyping was of immense use
later on, in understanding how the pieces fitted together.
.pp
During coding of Spider, the main problem encountered was organizing
everything in a coherent fashion.  It would have been easier
(initially) just to sit down and code without structure, but by
imposing a structure, it was easier to add pieces later.
.pp
Later on, when I started distributing the code, there was a problem in
that I needed to keep Alex updated with the latest version.  This was
readily solved by the use of two Unix utilities: diff(1) and patch(1),
which together allowed all changes since a previous version of the
source to be applied to a copy, thereby updating them.  Combined with
email, this made updates very easy indeed.
.pp
Overall, though the main problems inside Spider were all due to the
malloc call and it's friends.  In several places, my code had overrun
an allocated region of memory or tried to free the same piece of
memory twice.  Errors like these were speedily solved by linking with
a special version of malloc, which used hardware protection to ensure
that memory after an allocated region could not be utilized.
.pp
Most problems of communication between myself and Alex, were solved by
documenting what we wrote as soon as it had been done, that way, we
knew what each others code would do.  Again, combined with email,
this was a big win.
.pp
With the X Windows client, the problem was basically to ensure that
everything which needed to be done,
.i was
done.  For example, we needed to ensure that if a user select the
"Paging off" menu, then not only would the command be sent to the
server to turn off paging, but if we were not logged in at the time
the command was given, then the command would be given when we did log
on to the server.  This needed to be done in a general way, though.
Eventually, we came up with the solution of handlers, which are
basically arrays of Tcl code, which are executed at certain predefined
times, such as startup or connection.
.pp
Surprisingly, the rest of the X windows client went remarkably without
hitches.  Things which might have been expected to cause grief, such
as handling unsolicited messages or ensuring that messages came in one
go, were remarkably easy to do.
.\" 
.\" ############################################################
.\" 
.sh 1 "Experience Gained"
.lp
The most valuable experience that this project has given me is simply
that of programming at a professional development level.  By that I
mean, that code must be documented, there are deadlines to meet and
also there is a substantial chunk of program to be written.  
.pp
In specific areas of programming, I have also learned how to add
networking functions to programs in two different languages, and how
to handle multiplexing of network sockets.
.pp
In terms of design, we also learned how to work together to pull the
best of all of our ideas together, as taught to us last year.  Not
only that, but we successfully partitioned the work which had to be
done.
.\" 
.\" ############################################################
.\" 
.sh 1 "Future Ideas"
.lp
The project as it stands is complete; but it is not finished.  There
are many ideas which I have thought of since I finished coding to hand
in the work.  I will mention a few of them here.
.sh 2 "Spider"
.ip "Make code more efficient"
By this, I mean that it should handle several messages which come in
all together.  At present it does not do this, and loses any messages
after the first one.  
.ip "Convert trees to hashes internally"
At the moment, there are several places where tree structures are
used, where a hash would be far more efficient.
.ip "Make code more event driven"
As it stands, Spider is an event driven program, but the code does not
always clarify this situation.  I would like to correct this, so that
the code is cleaner and more understandable.
.ip "Reduce malloc usage"
Currently, there are about four calls to malloc(3) for every message
which passes through Spider.  If these could be eliminated, Spider
would be a lot faster.
.ip "Provide for administrative features"
It would be very useful for say an administrator to be able to kick
off a logged in user.  At present this is not supported.
.ip "Provide dynamicity"
This was one of the original goals of the project, but remains
uncompleted.  Spider should really be able to load in new modules on
demand. 
.sh 2 "X Windows Client"
.ip "Test UI"
The GUI needs testing to ensure that it works how people really want.
.ip "Whiteboard"
In conjunction with a module attached to Spider, a multi-user
whiteboard could fairly easily be implemented, in a similar way to
the talker.
.ip "Email"
Again, this is something which did not make it in, in time for the
project to be handed in.  Implementation should be fairly easy.
.ip "Dynamicity"
Because Tcl is an interpreted language, it is possible to send code
over a communications channel and execute it at the remote end.  There
are even special features in the language to make it safe to do so.
It would be very nice to be able to have the client request a portion
of code to deal with a new command which Spider had suddenly brought
on-line.  This would be very similar in the way in which Java is used
for Web Pages.
.\" 
.\" ############################################################
.\" 
.sh 1 "Conclusion"
.lp
Overall, I am pleased with what has happened with this project. I feel
that it has been a success, and that I have something that I can take
with me and show to prospective employers.