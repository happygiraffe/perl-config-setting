.\" ############################################################
.\" 
.\" This tells how to write an extension for Spider, or one of the two
 \" client written for it.
.\" 
 \" Here's a nice centered page number at the bottom:
.fo ''%''
.\" 
 \" $Id: extend.me,v 1.1 1999/03/11 15:39:49 dom Exp $
 \" 
.\" $Log: extend.me,v $
.\" Revision 1.1  1999/03/11 15:39:49  dom
.\" Initial revision
.\"
.\" Revision 1.1  1996/05/12 19:37:23  dom
.\" Changed several lists to blocks, so that they would stay together on
.\" the page.
.\"
.\" Revision 1.0  1996/05/06 18:41:02  dom
.\" Initial revision
.\"
.\"
.\" 
.(l C
.sz +8
Extension Writer's Guide
for Spider V1.0
by Dominic Mitchell
.sz -4
(\fCdom@myrddin.demon.co.uk\fP)
.sz +4
and Alex McLean
.sz -4
(\fCalex@area51.upsu.plym.ac.uk\fP)
.sz -4
.)l 
.sp 1i
.\" ############################################################
.\" 
.\" Module Writer's guide.
.\" 
.sh 1 "Module Writer's Guide"
.lp
.\" 
.sh 2 "What a module is"
.lp
Any Spider extension is an ordinary Unix executable program.  It adds
commands into the Spider protocol, which are made available to the
client software.
.\" 
.sh 2 "How the modules must work\**"
.(f
\** This is assuming that you are programming in C, and have a
reasonable understanding of the Standard I/O Library.
.)f
.lp
The module program must have three parts to it.  These are Setup,
Protocol Registering and the Command Processing Loop.
.pp
The setup part is very simple.  The module must first check that it is
not being driven interactively (usually by the isatty(3) function).
Then, it must set the buffering mode of it's stdin and stdout to line
buffered mode (usually via setvbuf(3)).  Finally, it must close it's
stderr (usually a connection to the system logger will be opened so
that errors may still be noted)\**.
.(f
\** A Module must never output unexpected data onto stdout (eg:
printing an error message).  If it does so, it runs the risk of
confusing Spider, which might well lock it up for all users.
.)f
.pp
In the Protocol Registering part, for each command it wishes to
register the module must print it onto stdout on a line of it's own
and wait for a reply from Spider.  If the Reply is OK_CMD, then the
command has been successfully registered.  If not, an error should be
logged, giving the circumstances.  This should be repeated for every
command that the module provides.  When all commands have been
registered, the module should print a single "." on a line of it's own
onto stdout to indicate to Spider that it has finished.  The module
should then enter the next part.
.pp
The final part is the Command Processing Loop. The module is expected
to read in a complete message (As defined in the protocol definition
document) from stdin.  The format of this message will be extended, in
that the username of the sender will be prepended to the beginning of
the first line of the message, for identification purposes.  The
module is expected to parse this message and create one or more reply
messages.  The reply message(s) will have the destination username
prepended to the first line of the message also.
.pp
Once the reply messages have been created, they must be printed onto
stdout, one at a time with a 0.1 second gap between them.  The slight
delay is currently necessary so that Spider does not accidentally lose
messages.  The need for this delay will be rectified in a later
version of Spider.
.pp
The module is then expected to loop around and read another message
from stdin, repeating the above process until it receives an EOF.  It
should then terminate normally.
.\" 
.sh 2 "The Spider Module Library"
.lp
As an aid to writing modules, a library of functions to perform the
above task is available.  Some of the modules which come with Spider
use it (motd, page, test).  It several categories of functions,
described below.  To use the library, your module must "\fC#include
<mod.h>\fP" at the top of the source file.  Then, it must be linked
with the library at compilation time.  If the library is in the
directory /u/spider/lib, then the command to link the module would
usually be something like "\fCcc -o mymodule mymodule.o
-L/u/spider/lib -lmod\fP"\**.
.(f
\** Again, this library assumes that you are using C to write your
modules.
.)f
.pp
For an example of using the module library, see the "motd" module in
the distribution, which is relatively simple.
.\" 
.sh 3 "Module Library Data Structures and Macros"
.lp
The first publically usable structure in the <mod.h> header file, is
called Reply.  It is defined to be an array of Spider Protocol
Messages, with a count of how many are contained within it.  It has
been declared with a typedef, so that it can be used like a standard
type.
.pp
Normally, a Spider Protocol Message is represented internally by an
array of pointers to strings.
.pp
The other useful declaration is the typedef Bool, which is an enum
representing the Boolean values false and true.
.pp
One macro has been declared, which is designed to assist in the
creation of reply structures.  It is called CUR_REP and takes one
parameter, which must be a variable of type Reply.  It returns a
pointer to the beginning of the last Spider Protocol Message contained
in the Reply, which may be used by all library functions which process
a single Spider Protocol Message.
.\" 
.sh 3 "Data Structure Support Functions"
.lp
These functions are used to easily manipulate data structures required
by the library.
.ip "\fCint arr_count(char ** array)\fP"
Given a pointer to an standard, NULL terminated array of pointers to
strings, will count the number of entries in the array and return this
value.  Hence, array[arr_count(array)] == NULL.
.\" 
.ip "\fCchar ** arr_add(char ** array, char * string)\fP"
Given a dynamically allocated array of pointers to strings, adds
string as a new member to the end of it.  Ensures that the last array
element will be NULL.  Returns a new pointer to the same array\**.
.(f
\** It is very important to save the result of this function, as it
calls realloc(3) and the address of the array may well change.
.)f
.\" 
.ip "\fCvoid arr_del(char **array)\fP"
This function will call free(3) for each of the strings contained
within array.  It will then free the array itself.
.\" 
.ip "\fCReply\** new_reply(Reply rep)\fP"
Given a Reply structure, this will start off a new message in the same
reply.  If all members of the structure rep have been initialized to
NULL or 0, then a new reply will be started instead.  This means that
it is important to call this function before attempting to use the
macro CUR_REP described in the previous section.
.(f
\** When declaring variables of this type, they may be initialized to
NULL by declaring "\fCReply rep = {NULL, 0};\fP"
.)f
.\"
.sh 3 "Token Parsing Functions"
.lp
These functions assist in splitting whitespace separated tokens.
.ip "\fCsize_t len_token(char * tok)\fP"
Return the length of tok,which is presumed to be separated by
whitespace from its surroundings else return 0 if buf is invalid or
there are less than n tokens in buf.
.\" 
.ip "\fCchar * find_token(char * buf, int n)\fP"
Return a pointer to the beginning of token n in buf, else return NULL
if buf is invalid or there are less than n tokens in buf.
.ip "\fCchar * copy_token(char * buf, int n)\fP"
Return a pointer to a dynamically allocated copy of token n in buf.
Caller must remember to free the result when finished.  Returns NULL
if buf is invalid or there are less than n tokens in buf.
.ip "\fCint num_tokens(char * buf)\fP"
Returns the number of tokens contained in buf, or zero if there are
none.  Note that this function is unusual in returning a one-based
value for the number of tokens, whereas all the other token functions
use a zero-based value for their arguments.  In this it is similar to
the strlen(3) function.
.ip "\fCBool cmp_token(char * buf, int n, char * s)\fP"
Compares token n in buf to the string s.  Returns true if they are
identical, false otherwise.  Even if one string is a substring of the
other, false will be returned.
.\" 
.sh 3 "Miscellaneous Functions"
.lp
These functions are generally quite useful.
.ip "\fCBool ck_buf(char * buf, int size)\fP"
This functions checks that buf does not contain any newlines and is
NULL terminated within the limit imposed by size.  It returns false if
this is not the case.
.ip "\fCchar * make_repline(char * name, int code, char * msg)\fP"
This function prepares an initial line of a Spider Protocol Message
reply.  Name is the person to which the message is intended to go and
code and msg are expected to correspond from the codes given in
Appendix A.1.  The resulting string is dynamically allocated and must
be freed by the caller.
.ip "\fCchar * make_unsolic(char * name, char * tag)\fP"
This function prepares an initial line of an unsolicited Spider
Protocol Message reply.  Name is the person to which the message is
intended to go and tag is the id of the originator of the message.
The resulting string is dynamically allocated and must be freed by the
caller.
.ip "\fCchar ** make_error(char * name, int code, char * msg)\fP"
This function prepares a minimal Spider Protocol Message reply, using
the above function "make_repline".  It then returns the pointer to a
standard message, rather than a string, which is ready to be inserted
directly into a Reply.
.\" 
.sh 3 "Module Part Functions"
.lp
These functions pertain to the three parts of a module described
earlier.
.ip "\fCvoid mod_init(char * name)\fP"
This function implements the setup part of a module.  The name which
is passed to it is used to initialize the error logger (syslog)
facility.
.ip "\fCvoid mod_reg_cmd(char * name, Reply(*func)(char ** input), void (*errf)(char ** input))\fP"
This function registers the command "name" with Spider and associates
the function "func" as the processor for this command and the function
"errf" as the error processing function for this command.  The data
types are more fully explained above, in section B.3.1.

There is a special case of this function.  When all passed arguments
are NULL, then the mod_reg_cmd function will pass the "I have finished
registering commands" message to Spider.  It is therefore necessary
that this function be called in this manner after all commands have
been registered.
.ip "\fCvoid mod_main_loop(void)\fP"
This function will enter an infinite loop. It will parse incoming
messages, pass them to the registered function, and dispatch any
output returned from the function.  It will continue to do so until it
receives an EOF on stdin, at which point it will exit gracefully.
Selected error messages from Spider will be passed to the registered
error function (errf), for further processing.  At present, only the
ERR_BADUSR error is forwarded in this way.

.sh 2 "Informing Spider about the presence of the module"
.lp
Once the module has been written, an appropriate entry must be
inserted into the spider.conf file.  This should be in the form
"Module = mymodule"\**.  If your module is also kept in a different
directory to one of the standard ones, then you must also add an entry
to the spider.conf file in the form "Module_Dir = /my/modules/dir".
.(f
\** The spaces around the "=" are necessary
.)f
.\" ############################################################
.\" 
.\" Extension Guide for Windows Client
.\" 
.sh 1 "Extension Guide for Windows Client"
.lp
.sh 2 "Introduction"
.lp
WinClient is written in Borland Delphi, a commercial compiler for
Microsoft Windows.  Before you can make changes to WinClient, you will
need a copy of the Delphi compiler.  Delphi is a fully object-oriented
Pascal derivative.
.pp
This is a quick guide to the structure behind the WinClient, intended
for fairly experienced Delphi programmers.  If you are new to Delphi
programming, you should read a good book on Delphi before attempting
to modify WinClient.
.\" 
.sh 2 "Sending a command to the server"
.lp
If we wanted to support a new server command, 'finger', that gave us
information about a user, here's how we could go about it.  Firstly,
we need to make up an command identifier for the client to
use. 'FINGER' will do.  Add this to the 'Command' type that is
specified at near the top of 'SOCKS.PAS'. ie: "\fCcommand = (NONE, QUIT,
LOGIN, MOTD, WHO, JOIN, BCHAN, GETARS, GETHED, SYNOFF, GETMSG, PUTMSG,
PAGEON, PAGESEND, FINGER)\fP";
.pp
Then, make sure that the 'socks' unit is included in the 'uses'
statement at the top of the unit the command will be called from.
.pp
This code would then send the command to the server:
.(b
\fCif StatusBox.Initcmd(FINGER) then
begin
	StatusBox.Sendline('finger ' + username);
	StatusBox.EndTrans;
end;\fP
.)b
.pp
Taking that a line at a time...
.ip "\fCif StatusBox.Initcmd(FINGER) then\fP"
"InitCmd" lets the socks unit know that we are sending a command.  The
value we pass it (FINGER in this case) lets it know what the command
is, so it knows what to do with the reply, when it is received.

If a command is already in progress, InitCmd will display a message
box informing the user, and then return false.
.\" 
.ip "\fCStatusBox.Sendline('finger ' + username);\fP"
"Sendline" adds a line (in the form of a Pascal string) to the
outgoing buffer, to send to the server.  In this case we are only
sending one line, the command itself.  Sendline can be called many
times in one command transmission, for example in a loop to send the
each line of a message.  Obviously, the command and it's arguments
must always be the first line you send.
.\" 
.ip "\fCStatusBox.EndTrans;\fP"
"EndTrans" sends the buffer to the server.  This must be done after
every command, and a reply must be received before another command can
be sent.  The protocol specifications dictate that only one command
can be sent at a time.

.sh 2 "Receiving a reply"
.lp
The above should allow you to send a command to a server, but in most
cases, you will also need to act on a reply.  Here is another excerpt
from "SOCKS.PAS":
.(b
\fCprocedure TStatusBox.ProcessReply;
var
  CmdCode : command;
begin
     CmdCode := CmdInProg;
     CmdInProg := NONE;
     case CmdCode of
       LOGIN : DoneLogin;
       MOTD : DoneMOTD;
       WHO : DoneWho;
       JOIN : TalkerBox.DoneJoin;
       GETARS : MsgBox.DoneGetars;
       GETHED : MsgBox.DoneGethed;
       SYNOFF : TalkerBox.DoneSynoff;
       GETMSG : MsgViewBox.DoneGetmsg;
     end;
end;\fP
.)b
This function is called when a reply to a command is received.  Adding
the following line to the case statement will call a function to
process replies to our 'finger' command:
.(b
       \fCFINGER : FingerBox.DoneFinger;\fP
.)b
Where FingerBox is the unit we're keeping our new code in, and
DoneFinger is the function called to process the reply.
.pp
The global variables that DoneFinger will need to use to access the
reply are 'long_output', an array of pointers to Pascal strings
containing the full reply, and 'output_lines', an integer containing
the number of lines received.
.pp
Long_output[0]^ should contain the reply code.  Subsequent lines could
contain further output, and the final line will always contain a
single full stop, and nothing else.
.pp
The following extract of code from the fictional FingerBox.DoneFinger
function would display the output in a listbox, missing off the first
line (reply code) and final line (terminator):
.(b
  \fCListbox1.Items.Clear;
  count := 1;
  while long_output[count]^ <> '.' do
    ListBox1.Items.Add(long_output[count]);\fP
.)b
.\" 
.sh 2 "Unsolicited messages"
.lp
The client-server protocol supports unsolicited messages, so the
server can surprise the client with a message at any time - even when
the client is expecting a reply from a command.  This is all handled
by existing code with WinClient.
.pp
Another excerpt from "SOCKS.PAS", this time from the
StatusBox.ParseUnsolicited function:
.(b
  \fCif tagtext = 'tmesg' then
    TalkerBox.ReceiveMessage
  else if tagtext = 'page' then
    PageBox.DisplayPage(Long_Output[1]^, Long_Output[2]^);\fP
.)b
This is a simple 'else if' structure, here it is again with an
addition for receiving a fictional unsolicited message that could tell
the client to beep:
.(b
  \fCif tagtext = 'tmesg' then
    TalkerBox.ReceiveMessage
  else if tagtext = 'page' then
    PageBox.DisplayPage(Long_Output[1]^, Long_Output[2]^)
  else if tagtext = 'beep' then
    BeepBox.MakeSomeNoise;\fP
.)b
Beepbox.MakeSomeNoise would then make the computer beep.  It can also
access to Long_Output and Output_Lines in the same way as
Fingerbox.DoneFinger has above.
.\" 
.sh 2 "World Wide Web Resources"
.lp
Two excellent on-line delphi resources:
.ip "\fChttp://www.borland.com/\fP"
Official Borland Delphi site.  The latest product information.
.ip "\fChttp://sunsite.icm.edu.pl/archive/delphi/\fP"
The Delphi Super Page. This is an excellent site, which shows off the
huge range of delphi freeware code available.  There are plenty of
delphi links from this page, so this is the only URL you'll need.
.\" ############################################################
.\" 
.\" Extension Guide for Tk Client
.\" 
.sh 1 "Extension Guide for Tk Client"
.lp
.sh 2 "Introduction"
.lp
The X Windows client for the BBS is written in a language called
Tcl/Tk.  An introductory WWW page is available from
"\fChttp://www.smli.com/research/tcl/\fP".  Extending the X Windows
client requires that one be reasonably familiar with the Tcl/Tk
language.  The X Windows client is also known as TkClient, because of
the language it is written in.
.sh 2 "Creating the User Interface"
.lp
Providing new functionality is usually done by adding an extra button
to the column of buttons on the right hand side.  The button, when
activated may either take control of the main panel (a label, a
listbox and a scrollbar), or it may choose to display it's own window.
.pp
These instructions assume that you are trying to add a command called "CMD".
.pp
To add the button for your extension, you must edit the file "ui.tcl".
In the first procedure (in the first couple of screens), there will be
a comment "# Buttons".  Below this is where the buttons are defined.
Put in an extra button for your command, after the last existing
button command. eg:
.(b
	\fCbutton .bt.CMD \\
		-padx 9 \\
		-pady 3 \\
		-text CMD \\
		-command BCMD\fP
.)b
Note that the button name (not the text, but the internal widget name)
must begin with ".bt.".
.pp
Next, you must move down a couple of screens to the next "# Button"
comment, which is followed by a series of "pack" commands.  These are
what cause your button to be displayed on the screen.  Again, add an
entry for your button after the existing pack commands. eg:
.(b
	\fCpack .bt.CMD \\
		-anchor n \\
		-fill x\fP
.)b
.pp
Now, a command to back up your button must be provided. This will be a
procedure at the bottom of the "cmds.tcl" file, with the name "BCMD".
This procedure has a choice.  It may take over the main panel or it
can display it's own toplevel window.
.pp
If it wishes to take over the main display, then it must set the
global variable \fCAfAreaState\fP to it's own name (eg: CMD), before
modifying the widgets ".af.area_label" and ".af.area_list".  It must
also redefine the binding for <Double-Button-1> as this is set by each
button which takes over the main display.
.pp
To display a new window, it is normal to call a procedure to set up
the user interface and then just return.  If the new window is even
slightly complicated, it is usually best to isolate the procedure in a
separate file.  To get tkclient to load in the new file, the file
"tkclient.in" must be edited, and a new source command added for your
file at the bottom of all the others.  For this change to take effect,
you must then do "make install" from the Unix shell prompt.
.sh 2 "Input/Output"
.lp
I/O is handled easily by the existing code framework.  When you need
to send a command to Spider, the usual construct is:
.(b
    \fCif {! [Connected]} {
        return
    }

    set mycmd [DoCmd [list "CMD param1 param2"]]
    if [TestForError $mycmd] {
        return
    }
    set mycmd [lrange $mycmd 1 end]\fP
.)b
.pp
The first section simply uses the procedure "Connected" to ensure that
we are actually on-line.  If not, then the command backs out of doing
anything.
.pp
Next, the procedure "DoCmd" is called, with a list as it's argument.
Each member of the list is a line to send to Spider.  You must not
provide a final "." on a line of it's own, as the DoCmd procedure will
add one for you.  It is very important here to use the list function
to provide the arguments, so that constructs such as parameters to a
command are not interpreted as separate lines.  The reply saved into
the "mycmd" variable is the result of the output from Spider, except
that it does not include the terminating "." on a line of it's own.
.pp
The procedure "TestForError" is then called with reply from Spider, to
check that it it an "OK" reply.  If not, a dialog box will be placed
on the screen, for the user to note what went wrong and TestForError
will return false.  In that case, your function should exit
immediately, undoing whatever it need to look as if it had not been
called.
.pp
The last "set" statement merely removes the reply code from the Reply
that Spider sent, so that the remaining list contains just the lines
of the reply.
.sh 2 "Handlers"
.lp
It may be the case that your extension needs to execute code at a
specific time.  This is possible through the use of several global
arrays.
.pp
To execute a procedure when tkclient has just started put into your
code "set InitHandlers(CMD) CMDInit", where CmdInit is the procedure
you wish to be executed.  Note that if you are executing this command
inside a procedure, you will need to declare InitHandlers as a global
variable prior to use.
.pp
You can have a procedure executed when a new connection is established
by using the global array ConnectHandlers nd doing the same as above.
Similarly for disconnecting and the global array DisConnectHandlers.
.pp
Finally, if you wish to receive unsolicited messages from Spider,
then you can set an entry in the global array AsyncHandlers.  The name
you set in this array must be the same name as the tag in the
unsolicited messages you wish to receive (see Protocol Definition
Document).  For example, the talker button would set
AsyncHandlers(tmesg) to it's Unsolicited Message handler.
.\" 
.\" The following is for emacs to behave correctly.
.\" 
.\" Local variables:
.\" mode: nroff
.\" End:
.\" 
